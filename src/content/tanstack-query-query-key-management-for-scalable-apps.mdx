---
title: "Tanstack Query: Query Key Management for Scalable Apps"
description: "Organize your Tanstack Query keys for better scalability and maintainability."
publishDate: "2025-01-31"
isPublished: true
slug: "tanstack-query-query-key-management-for-scalable-apps"
---

import { CustomLink } from "@/components/mdx-components/custom-link";
import { CustomImage } from "@/components/mdx-components/custom-image";
import { Callout } from "@/components/mdx-components/callout";

<CustomImage
  src="/assets/images/tanstack-query-query-key-management-for-scalable-apps/header.avif"
  alt="Tanstack Query: Query Key Management for Scalable Apps"
  photoBy="Unsplash"
  photoByLink="https://unsplash.com"
/>

## The Growing Pains of Query Keys

We've all been there - you start a new project with Tanstack Query (formerly React Query), blissfully hardcoding query keys like there's no tomorrow. But as your app grows, you find yourself:

🔍 Hunting through 15 files to update a key structure\
💥 Accidentally invalidating the wrong queries\
🕵️♂️ Playing detective with cache mismatches

As your application grows, so does the complexity of managing query keys in Tanstack Query. In this post, I'll explore a few different strategies for organizing those keys and discover how to future-proof your data layer.

## Stage 1: Hardcoded Query Keys

In the early stages of development, it’s common to hardcode query keys directly in custom hooks. It's quick and easy to get started
For example:

```ts
export function useGetPosts({ sort, order }: PostSortingCriteria) {
  return useQuery({
    queryKey: ["posts", "list", { sort, order }],
    queryFn: () => getPosts({ sort, order }),
  });
}
```

But as soon as you need to invalidate several queries—for example, after creating a new post—you have to remember each query key and invalidate them individually:

```ts
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["posts", "list"] });
  },
});
```

🛑 Pitfalls:

- Cache invalidation guessing game
- String typos become silent failures
- No single source of truth

## Stage 2: The Constants Approach

Instead of hardcoding query keys in each hook, you can keep them in one place for easier reuse. For example

```ts
export const POSTS = ["posts"];
export const POSTS_LIST = ["posts", "list"];
export const POST_LIST_BY_SORT = (sort: string, order: string) => [
  "posts",
  "list",
  { sort, order },
];
export const POST_DETAIL = (id: number) => ["posts", id];
export const POST_COMMENTS = (id: number) => ["posts", id, "comments"];
```

✅ Improvements:

- Reduced string duplication
- Clearer key relationships
- Easier mass invalidations

⚠️ New Challenges:

- File becomes a dumping ground
- No inherent type safety
- "Constants fatigue" with 50+ exports

## Stage 3: **Query Key Factories** (The Architect's Blueprint)

### Why Query Key Factories?

When your codebase grows, scattering query keys throughout files or repeating them in multiple hooks can become a maintenance headache. Query Key Factories group related keys in a single place and make your data-fetching layer more organized and scalable.

### Level 1: Basic Query Key Factory

A basic version of a “factory” for posts might look like this:

```ts
export const postQueryKey = {
  all: ["posts"],
  allList: ["posts", "list"],
  list: ({ sort, order }: PostSortingCriteria) => [
    "posts",
    "list",
    { sort, order },
  ],
  detail: (id: number) => ["posts", id],
  comments: (id: number) => ["posts", id, "comments"],
};
```

✅ Improvements:

- Resource-focused organization

⚠️ Limitations:

- Still contains duplicate `"posts"` strings
- No type inference for query key structure

### Level 2: Composition-Based Factory

Instead of repeating `"posts"` in every key, we build from a base key. Here’s how that might look:

```ts
export const postQueryKeys = {
  all: () => ["posts"] as const,
  allList: () => [...postQueryKeys.all(), "list"] as const,
  list: ({ sort, order }: PostSortingCriteria) =>
    [...postQueryKeys.allList(), { sort, order }] as const,
  detail: (id: number) => [...postQueryKeys.all(), id] as const,
  comments: (id: number) => [...postQueryKeys.detail(id), "comments"] as const,
};
```

✅ Improvements:

- Composition: Build complex keys from simple foundations
- Type-safety: `as const` preserves tuple literal types
- Refactor Resilience: Change `all()` key once to update all descendants

As a result, now you capable of:

```ts
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: postQueryKeys.all() });
  },
});
```

### Level 3: Full Query Factory

To take it a step further, you can bundle query options with the key itself. This way, you can define the full query configuration in one place this pattern called **Query Factories**

**Note**: _`queryOptions` is a part of Tanstack Query V5. Even if you are using an older version, you can still use this pattern without it._

```ts
import { queryOptions } from "@tanstack/react-query";

// Create one factory for all post-related queries
export const postsQueries = {
  // Keep `queryKey` and `queryFn` close (using queryOptions to bundle them)

  // Use const assertions for better type inference
  all: () =>
    queryOptions({
      queryKey: ["posts"] as const,
    }),

  // Compose from simpler keys
  allList: () =>
    queryOptions({
      queryKey: [...postsQueries.all().queryKey, "list"] as const,
    }),

  // A key that includes a query function as well
  list: ({ direction, sortBy }: PostsSortCriteria) =>
    queryOptions({
      queryKey: [
        ...postsQueries.allList().queryKey,
        { direction, sortBy },
      ] as const,
      queryFn: () => fetchPosts(sortBy, direction),
    }),

  // A detail key that extends the base key
  details: (postId: number) =>
    queryOptions({
      queryKey: ["post", postId] as const,
      queryFn: () => fetchPostById(postId),
    }),

  // A comments key building on the detail key
  comments: (postId: number) =>
    queryOptions({
      queryKey: [...postsQueries.details(postId).queryKey, "comments"] as const,
      queryFn: () => fetchPostComments(postId),
    }),
};
```

🥇 Here’s why this approach is **Gold Standard**:

- Complete Type Safety
- Centralized Query Configuration
- Colocated Logic: Query functions live with their keys
- Optimized Usage: Full type-checked usage, Easy option overriding
- Atomic Updates
- Discoverability: IDE autocomplete for query keys

### Putting It All Together (Usage)

With Query Key Factories in place, using these keys in your components is straightforward:

```ts
// Strictly typed query key
// key: readonly ["posts", "list", { direction: "asc", sortBy: "title" }]
const key = postsQueries.list({ direction: "asc", sortBy: "title" }).queryKey;

// Fetching a sorted list of posts
const { data } = useQuery(postQueryKeys.list({ sort: "title", order: "asc" }));

// Overriding options while using the factory’s defaults
const { data } = useQuery({
  ...postQueryKeys.detail(1),
  staleTime: 1000,
});

// Invalidating all post-related queries
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries(postQueryKeys.all());
  },
});
```

## The Payoff: A Maintainable Future

✅ Never grep for `"posts"` across files again\
✅ Onboard new developers faster\
✅ Sleep well knowing cache invalidations are precise\
✅ Easily refactor data dependencies

## Final Thoughts

Query Key Factories keep your Tanstack Query usage clean, organized, and easier to maintain. By structuring keys around a resource, composing them to avoid duplication, and returning the full set of query options, you’ll have a more consistent, scalable, and discoverable data-fetching layer.

There’s a community library called <CustomLink href="https://github.com/lukemorales/query-key-factory">query-key-factory</CustomLink> that provides utilities for structuring and managing Tanstack Query keys. It’s well worth checking out if you’re interested in this pattern.

And other resources I found helpful:

1. <CustomLink href="https://tkdodo.eu/blog/effective-react-query-keys">
     Effective React Query Keys
   </CustomLink>

2. <CustomLink href="https://tkdodo.eu/blog/the-query-options-api">
     The Query Options API
   </CustomLink>

3. <CustomLink href="https://tanstack.com/query/latest/docs/framework/react/guides/query-keys">
     Tanstack Query: Query Keys
   </CustomLink>

4. <CustomLink href="https://www.youtube.com/watch?v=8KWMOCW6LCU">
     Tanstack Query, Query Keys Best Practices (YouTube)
   </CustomLink>

5. <CustomLink href="https://github.com/inam95/tanstack-playground">
     Example with Query Key Factories
   </CustomLink>
