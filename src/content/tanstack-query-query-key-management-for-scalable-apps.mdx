---
title: "Tanstack Query: Query Key Management for Scalable Apps"
description: "Organize your Tanstack Query keys for better scalability and maintainability."
publishDate: "2024-03-04"
isPublished: true
slug: "tanstack-query-query-key-management-for-scalable-apps"
---

import { CustomLink } from "@/components/mdx-components/custom-link";

As your application grows, so does the complexity of managing query keys in Tanstack Query. In this post, I'll explore a few different strategies for organizing those keys and share the approach I’ve found to be most effective.

## Approach 1: Hardcoded Query Keys

In the early stages of development, it’s common to hardcode query keys directly in custom hooks.\
For example:

```ts
export function useGetPosts({ sort, order }: PostSortingCriteria) {
  return useQuery({
    queryKey: ["posts", "list", { sort, order }],
    queryFn: () => getPosts({ sort, order }),
  });
}
```

This setup is simple and works fine when your app is small. But as soon as you need to invalidate several queries—for example, after creating a new post—you have to remember each query key and invalidate them individually:

```ts
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["posts", "list"] });
  },
});
```

Hardcoding is easy to start with but can become cumbersome to maintain in larger applications.

## Approach 2: Define Query Keys in a separate file as constants

Instead of hardcoding query keys in each hook, you can keep them in one place for easier reuse. For example

```ts
export const POSTS = ["posts"];
export const POSTS_LIST = ["posts", "list"];
export const POST_LIST_BY_SORT = (sort: string, order: string) => [
  "posts",
  "list",
  { sort, order },
];
export const POST_DETAIL = (id: number) => ["posts", id];
export const POST_COMMENTS = (id: number) => ["posts", id, "comments"];
```

This is a step in the right direction—you centralize keys and avoid scattering them throughout your code. However, a few issues can surface:

- **File bloat**: As the application grows, this file can become massive.
- **Ambiguity**: It’s not always clear which resource a key belongs to.
- **Navigation** hurdles: New team members (or even you, after some time) might find it tricky to locate the right constant.
- **Repetition**: Shared fragments like "posts" or "list" are repeated in multiple keys.

## Approach 3: **Query Key Factories** (My preferred approach)

### Why Query Key Factories?

When your codebase grows, scattering query keys throughout files or repeating them in multiple hooks can become a maintenance headache. Query Key Factories group related keys in a single place and make your data-fetching layer more organized and scalable.

### Basic Implementation

A basic version of a “factory” for posts might look like this:

```ts
export const postQueryKey = {
  all: ["posts"],
  allList: ["posts", "list"],
  list: ({ sort, order }: PostSortingCriteria) => [
    "posts",
    "list",
    { sort, order },
  ],
  detail: (id: number) => ["posts", id],
  comments: (id: number) => ["posts", id, "comments"],
};
```

However, you can take this further to clean up the `hardcoded` strings and add more clarity.

### Refining Query Key Factories

Instead of repeating `"posts"` in every key, we build from a base key. Here’s how that might look:

```ts
export const postQueryKeys = {
  all: () => ["posts"],
  allList: () => [...postQueryKeys.all(), "list"],
  list: ({ sort, order }: PostSortingCriteria) => [
    ...postQueryKeys.allList(),
    { sort, order },
  ],
  detail: (id: number) => [...postQueryKeys.all(), id],
  comments: (id: number) => [...postQueryKeys.detail(id), "comments"],
};
```

By composing from smaller keys (_all_, _allList_, etc.), you avoid hardcoding the same strings everywhere and keep your keys structured and more intuitive.

```ts
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: postQueryKeys.all() });
  },
});
```

### Best Practices (with an Example)

Below is a more advanced example that also incorporates recommended best practices. Notice how\
we:

1. **Use const assertions** for better type inference.
2. Keep `queryKey` and `queryFn` together for clarity.
3. **Create one factory per resource** (this example is for posts).
4. **Leverage composition** to build on simpler keys.

```ts
import { queryOptions } from "@tanstack/react-query";

// Create one factory for all post-related queries
export const postQueryKeys = {
  // Keep `queryKey` and `queryFn` close (using queryOptions to bundle them)

  // Use const assertions for better type inference
  all: () =>
    queryOptions({
      queryKey: ["posts"] as const,
    }),

  // Compose from simpler keys
  allList: () =>
    queryOptions({
      queryKey: [...postQueryKeys.all(), "list"] as const,
    }),

  // A key that includes a query function as well
  list: ({ sort, order }: PostSortingCriteria) =>
    queryOptions({
      queryKey: [...postQueryKeys.allList(), { sort, order }],
      queryFn: () => fetchPosts({ sort, order }),
    }),

  // A detail key that extends the base key
  detail: (id: number) =>
    queryOptions({
      queryKey: [...postQueryKeys.all(), id],
      queryFn: () => fetchPost(id),
    }),

  // A comments key building on the detail key
  comments: (id: number) =>
    queryOptions({
      queryKey: [...postQueryKeys.detail(id), "comments"],
      queryFn: () => fetchComments(id),
    }),
};
```

Here’s why this approach is effective and powerful:

- You can see at a glance how data is fetched and how it’s keyed.
- It's easy to extend or modify keys without breaking other parts of your code.

### Putting It All Together (Usage)

With Query Key Factories in place, using these keys in your components is straightforward:

```ts
// Example 1: Fetching a sorted list of posts
const { data } = useQuery(postQueryKeys.list({ sort: "title", order: "asc" }));

// Example 2: Overriding options while using the factory’s defaults
const { data } = useQuery({
  ...postQueryKeys.detail(1),
  staleTime: 1000,
});

// Example 3: Invalidating all post-related queries
useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    queryClient.invalidateQueries(postQueryKeys.all());
  },
});
```

Because everything is centrally defined, you only need to call the relevant factory function—no more searching for the right query key string.

## Final Thoughts

Query Key Factories keep your Tanstack Query usage clean, organized, and easier to maintain. By structuring keys around a resource, composing them to avoid duplication, and returning the full set of query options, you’ll have a more consistent, scalable, and discoverable data-fetching layer.

There’s a community library called <CustomLink href="https://github.com/lukemorales/query-key-factory">query-key-factory</CustomLink> that provides utilities for structuring and managing Tanstack Query keys. It’s well worth checking out if you’re interested in this pattern. The main caveat is that it closely tracks Tanstack Query updates—so whenever Tanstack Query evolves, this library may require an update as well.

And other resources I found helpful:

1. <CustomLink href="https://tkdodo.eu/blog/effective-react-query-keys">
     Effective React Query Keys
   </CustomLink>

2. <CustomLink href="https://tkdodo.eu/blog/the-query-options-api">
     The Query Options API
   </CustomLink>

3. <CustomLink href="https://tanstack.com/query/latest/docs/framework/react/guides/query-keys">
     Tanstack Query: Query Keys
   </CustomLink>

4. <CustomLink href="https://www.youtube.com/watch?v=8KWMOCW6LCU">
     Tanstack Query, Query Keys Best Practices (YouTube)
   </CustomLink>
